package com.myappteam.microservice.auth.utility;

import java.nio.charset.Charset;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.log4j.Logger;
import org.springframework.http.HttpHeaders;

public class CryptographicUtility {

	private static Logger logger = Logger.getLogger(CryptographicUtility.class);

	/**
	 * Generate a secured random byte array with length 32
	 * 
	 * @return the generated byte array
	 */
	public static byte[] generateSecureRandom() {
		final Random r = new SecureRandom();
		byte[] salt = new byte[32];
		r.nextBytes(salt);
		return salt;
	}

	/**
	 * 
	 * @param passcode
	 * @param salt
	 *            Base64 representation of salt
	 * @return the hash of the passcode/salt combination or <tt>null</tt> if
	 *         anything has gone wrong.
	 */
	public static synchronized byte[] encode(char[] passcode, byte[] salt) {
		int iterations = 1024;
		int keyLength = 256;
		KeySpec keySpec = new PBEKeySpec(passcode, salt, iterations, keyLength);
		SecretKeyFactory factory;
		byte[] key = null;
		try {
			factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
			key = factory.generateSecret(keySpec).getEncoded();
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (InvalidKeySpecException e) {
			e.printStackTrace();
		}
		return key;
	}

	public static byte[] decrypt(final byte[] key, final byte[] ciphertext,
			final byte[] iv) {
		SecretKey secret = new SecretKeySpec(key, "AES");
		byte[] plaintext = null;
		Cipher cipher;
		try {
			cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
			plaintext = cipher.doFinal(ciphertext);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		} catch (InvalidKeyException e) {
			e.printStackTrace();
		} catch (InvalidAlgorithmParameterException e) {
			e.printStackTrace();
		} catch (IllegalBlockSizeException e) {
			e.printStackTrace();
		} catch (BadPaddingException e) {
			logger.error(e.getMessage());
		}
		return plaintext;
	}

	/**
	 * 
	 * @param key
	 *            The key to encrypt with
	 * @param data
	 *            They data to be encrypted
	 * @return A {@link Map} object containing two entries:
	 *         <ol>
	 *         <li>the ciphertext</li>
	 *         <li>the initialisation vector for this ciphertext</li>
	 *         </ol>
	 */
	public static Map<String, byte[]> encrypt(final byte[] key,
			final byte[] data) {
		SecretKey secret = new SecretKeySpec(key, "AES");
		Map<String, byte[]> map = new HashMap<String, byte[]>();

		try {
			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			cipher.init(Cipher.ENCRYPT_MODE, secret);
			AlgorithmParameters params = cipher.getParameters();
			byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
			byte[] ciphertext = cipher.doFinal(data);
			map.put("ciphertext", ciphertext);
			map.put("iv", iv);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		} catch (InvalidKeyException e) {
			e.printStackTrace();
		} catch (InvalidParameterSpecException e) {
			e.printStackTrace();
		} catch (IllegalBlockSizeException e) {
			e.printStackTrace();
		} catch (BadPaddingException e) {
			e.printStackTrace();
		}
		return map;
	}

	public static HttpHeaders createBasicAuthenticationHeader(
			final String username, final String password) {
		return new HttpHeaders() {
			private static final long serialVersionUID = 1L;

			{
				String auth = username + ":" + password;
				byte[] encodedAuth = Base64.encodeBase64(auth.getBytes(Charset
						.forName("US-ASCII")));
				String authHeader = "Basic " + new String(encodedAuth);
				set("Authorization", authHeader);
			}
		};
	}
}
